*********lsd在做一些变换时很多都认为是小基线的变换，忽略了旋转量，因此对于旋转较多的情况效果会不好
*********小基线情况下的极线匹配搜索范围更小(优势)


tracking部分：
作用：跟踪每一个进来的帧的位姿，并判断是否增加关键帧
1、每一帧的的位姿估计都是前一帧估计成功的帧
2、跟踪成功后，都将当前帧的尺度进行归一化，这样可以方便对下一帧的跟踪（由于每一帧都进行了尺度归一化，因此肯定会存在一定的尺度误差）
3、keyFrameGraph->allFramePoses记录了所有跟踪成功的帧，不仅仅是关键帧
4、每次跟踪的参考关键帧trackingReference都是currentKeyFrame，也就是系统当前的关键帧
5、跟踪方式：从高阶金字塔到低阶金字塔迭代优化位姿(高阶金字塔得到的位姿作为低阶金字塔的初始值)
             目标函数是论文中的公式12,即光度误差，用LM算法进行优化求解
5、若相机运动较远，则设置增加关键帧标志：createNewKeyFrame，在后面的进程中增加关键帧
6、最后在unmappedTrackedFrames中添加当前帧，作为后续进程增加关键帧或者refine关键帧


Mapping部分：主函数（doMappingIteration（））
todo：map中有两种帧：activeKeyFrame（当前关键帧的图像信息）、currentDepthMap（当前关键帧的深度信息）
作用：增加关键帧或者refine关键帧（其中，createNewKeyFrame只是粗略的搞了一个深度，是不太准确的，需要后续的refine）
若createNewKeyFrame，则使用1,2：
1、finishCurrentKeyframe函数作用：a）通过周围5x5格子内已知深度的像素点为currentDepthMap中部分未知深度的像素点融合出像素点
                                     也就是说假如在这个方格内有大量点被观测了深度，那么剩下的点理论上也应该能够被估计深度
                                     我们可以通过这些未知深度的点周围那些已知深度的点来融合出这些点的深度
                                 b）对currentDepthMap进行深度的融合，平滑，并去除坏点
2、changeKeyframe函数作用：创建新的关键帧，构建它的深度地图（propagateDepth函数），并把深度地图的平均深度和关键帧的位姿归一化，（虽然进行了尺度归一化，但还是把前后两帧的尺度变化放入了Sim3中）方便后续的sim3优化
                          a）propagateDepth函数作用：将前一关键帧帧的深度像素投影到当前关键帧，若光度误差较小则三角化该像素点，最后更新关键帧

若不createNewKeyFrame，则使用3:
3、updateKeyframe函数的作用：取出tracking中unmappedTrackedFrames的所有帧，根据像素的新和旧选择最前面或者最后面的帧用来refine当前关键帧
                       todo：1、只有在updateKeyframe函数的作用采用了极线搜索，其他地方都是直接投影的
                             2、前期计算极线过程中，在极线上会删除那些a)梯度方向极线方向垂直的；b)在极线上梯度不够分明的点
                             3、对于新旧帧的选取权衡：旧帧对应这长基线，新帧对应着短基线；长基线匹配精度更高，但容易陷入局部最优；短基线由于噪声的影响精度不高，但是不会陷入局部最优
                       具体：a）observeDepthCreate：将关键帧中梯度够大但没有深度的像素投影到参考帧，做极线匹配（采用在极线上的连续5个像素点作为图像快进行搜索），此时假设该像素的深度为1,从而确定一个极线线段，通过光度误差判断得到一个合理的匹配点，从而得到深度估计；
                             b）observeDepthUpdate：将关键帧中有深度的像素投影到参考帧，做极线匹配（采用在极线上的连续5个像素点作为图像快进行搜索），此时的假设深度直接有已知的深度提供，得到深度后与之前的那个深度做了深度滤波。


globalMapping部分：
1、所有的帧的位姿都是以sim3保存的（而且保证了每一帧图像的平均深度为1），所以之后的tracking都要做se3FromSim3变换
   todo：在每创建一个keyframe之后，keyframe的深度图和位姿的尺度都会被归一化（也就是深度图的平均深度为1），而在tracking部分直接将sim3位姿转换成se3
         因为两帧之间只要做相对的像素投影，误差不会很大


限制搜索部分：
作用：为新加入的关键帧或者那些需要重新track的关键帧在地图中用2种方法（欧式距离较近，fabmap相近也就是共视的）搜索关联的帧，建立这些帧之间的位姿关系，构建位姿图
函数调用：constraintSearchThreadLoop--->findConstraintsForNewKeyFrames--->testConstraint
         主要testConstraint函数：分别在各个金字塔下计算两帧之间的sim3变换，作用两帧之间的sim3边，用于图优化
优化目标：光度误差+尺度误差
         TODO：1、在对当前帧和对应帧求变换矩阵之前，对估计值加入了一个小扰动，可以提供一个比较快速的解
               2、**重要** 里面的constrain主要有两种：a)因为欧式距离近而形成的closeCandidates；b）因fabmap而形成的具有较好共视关系的farCandidates
               3、constrains也就构成了PoseGraph的边，可以为后续的优化作准备


缺点：1、很多地方忽略了旋转量，降低了精度
      2、实际测试中发现对动态环境的鲁棒性没有orb好（虽然加入了huber算子，加入了去遮挡的过程）


